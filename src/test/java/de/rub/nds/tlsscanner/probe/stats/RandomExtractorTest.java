/**
 * TLS-Scanner - A TLS configuration and analysis tool based on TLS-Attacker.
 *
 * Copyright 2017-2019 Ruhr University Bochum / Hackmanit GmbH
 *
 * Licensed under Apache License 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */
package de.rub.nds.tlsscanner.probe.stats;

import de.rub.nds.tlsattacker.core.protocol.message.ClientHelloMessage;
import de.rub.nds.tlsattacker.core.workflow.WorkflowTrace;
import de.rub.nds.tlsattacker.core.state.State;
import de.rub.nds.tlsattacker.core.workflow.action.ReceiveAction;
import de.rub.nds.tlsattacker.core.workflow.action.SendAction;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import de.rub.nds.tlsattacker.core.protocol.message.ServerHelloMessage;
import de.rub.nds.tlsattacker.core.constants.ProtocolMessageType;
import de.rub.nds.tlsattacker.core.protocol.message.ProtocolMessage;
import de.rub.nds.tlsattacker.core.workflow.WorkflowTraceUtil;
import de.rub.nds.tlsattacker.core.config.Config;

import java.util.List;

import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;

/**
 * Test-Class for RandomExtractor.java, which currently looks for the
 * serverHello-message of the TLS-Handshake and extracts the random-bytes
 * transmitted
 *
 * @author Dennis Ziebart - dziebart@mail.uni-paderborn.de
 */
public class RandomExtractorTest {

    WorkflowTrace trace_empty;
    Config config_empty;
    RandomExtractor extractor;
    private final Logger LOGGER = LogManager.getLogger();
    SendAction testClientHello;

    public RandomExtractorTest() {
    }

    @Before
    /**
     * Prepare various handshake-messages for testing
     */
    public void setup() {
        // create workflow trace, which RandomExtractor will check for
        // random-values
        trace_empty = new WorkflowTrace();
        config_empty = Config.createConfig();
        extractor = new RandomExtractor();

        testClientHello = new SendAction();
        // ReceiveAction testClientHello = new ReceiveAction();
        ClientHelloMessage msg_client = new ClientHelloMessage();
        byte[] client_random = new byte[] { 6, 7, 8, 9, 10, 11 };
        msg_client.setRandom(client_random.clone());
        testClientHello.setMessages(msg_client);

    }

    /**
     * Testing a valid handshake-message
     */
    @Test
    public void testValidExtract() {
        ReceiveAction testServerHello = new ReceiveAction();
        ServerHelloMessage msg = new ServerHelloMessage();
        // Generate some random bytes
        byte[] server_random = new byte[] { 0, 1, 2, 3, 4, 5, };

        trace_empty.addTlsAction(testClientHello);

        // Fill ServerHello-random with generated bytes
        msg.setRandom(server_random.clone());
        testServerHello.setMessages(msg);
        trace_empty.addTlsAction(testServerHello);

        // Sanity-check
        List<ProtocolMessage> allReceivedMessages = WorkflowTraceUtil.getAllReceivedMessages(trace_empty,
                ProtocolMessageType.HANDSHAKE);
        // LOGGER.info(allReceivedMessages.toString());

        State state = new State(trace_empty);
        extractor.extract(state);

        // Sanity-check
        // byte[] extracted_number = extractor.getContainer().getExtractedValueList().get(0).getArray();
        // LOGGER.info(Arrays.equals(server_random, extracted_number));


        ComparableByteArray generated_random = new ComparableByteArray(server_random);
        ComparableByteArray extracted_random = extractor.getContainer().getExtractedValueList().get(0);

        // Check if only one value was extracted and if it is equal to the
        // pre-defined random-bytes
        assertEquals(1, extractor.getContainer().getNumberOfExtractedValues());
        assertEquals(generated_random, extracted_random);
    }

    /**
     * Testing handshake-message without ServerHello
     */
    @Test
    public void testNoServerHelloExtract() {
        trace_empty.addTlsAction(testClientHello);
        State state = new State(trace_empty);
        extractor.extract(state);

        assertEquals(0, extractor.getContainer().getExtractedValueList().size());
    }

    /**
     * Following Block actually crashes with null-pointer-exception when
     * extracting the state. Before incorporating this test, one has to ensure
     * first, that using the extract-function on a trace which has no
     * ServerHello-random-bits results in an empty Container rather than
     * throwing a nullpointer-exception.
     */
    /*
     * @Test public void testNoRandomToExtract() {
     * trace_empty.addTlsAction(testClientHello); ReceiveAction testServerHello
     * = new ReceiveAction(); ServerHelloMessage msg = new ServerHelloMessage();
     * testServerHello.setMessages(msg);
     * trace_empty.addTlsAction(testServerHello); State state = new
     * State(trace_empty); extractor.extract(state); assertEquals(0,
     * extractor.getContainer().getExtractedValueList().size()); }
     */

}